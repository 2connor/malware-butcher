import hashlib
import os
import re
import struct

# "MZ"
mz_bytes = b'\x4D\x5A'
# "This program cannot be run in DOS mode."
pe_dos_stub = b'''\
\x0E\x1F\xBA\x0E\x00\xB4\x09\xCD\
\x21\xB8\x01\x4C\xCD\x21\x54\x68\
\x69\x73\x20\x70\x72\x6F\x67\x72\
\x61\x6D\x20\x63\x61\x6E\x6E\x6F\
\x74\x20\x62\x65\x20\x72\x75\x6E\
\x20\x69\x6E\x20\x44\x4F\x53\x20\
\x6D\x6F\x64\x65\x2E\x0D\x0D\x0A'''
# "This program must be run under Win64."
pe_win64_stub = b'''\
\xBA\x10\x00\x0E\x1F\xB4\x09\xCD\
\x21\xB8\x01\x4C\xCD\x21\x90\x90\
\x54\x68\x69\x73\x20\x70\x72\x6F\
\x67\x72\x61\x6D\x20\x6D\x75\x73\
\x74\x20\x62\x65\x20\x72\x75\x6E\
\x20\x75\x6E\x64\x65\x72\x20\x57\
\x69\x6E\x36\x34\x0D\x0A\x24\x37'''

pe_output_dir = "pe"
hash_output = "file-hash-list.txt"
data = b''

start_list = []
end_list = []

# find DOS stubs and then return the position 64 bytes back
# this should be where the "MZ" bytes appear
# if so this position is appended to the start_list array
def find_stubs():
    for stub in re.finditer(re.escape(pe_dos_stub), data):
        start = stub.start() - 64
        if (data[start:start + 2] == mz_bytes):
            start_list.append(start)
            
    for stub in re.finditer(re.escape(pe_win64_stub), data):
        start = stub.start() - 64
        if (data[start:start + 2] == mz_bytes):
            start_list.append(start)

# calculate the size of a file
# based on the data in the file header and section table
def find_size(mz_pos):
    total_size = 0

    # find PE signature
    pe_start = data[mz_pos:mz_pos + 512].find(b'\x50\x45\x00\x00')
    pe_start += mz_pos

    size_of_headers = data[pe_start + 84:pe_start + 88]
    # little endian 4 byte unsigned int
    size_of_headers = struct.unpack("<I", size_of_headers)[0]
    total_size += size_of_headers

    number_of_sections = data[pe_start + 6:pe_start + 8]
    # little endian 2 byte unsigned short
    number_of_sections = struct.unpack("<H", number_of_sections)[0]

    # ".text   "
    # this should be the first section in the section table
    text = b'\x2E\x74\x65\x78\x74\x00\x00\x00'
    first_section = data[pe_start:pe_start + 512].find(text) + 16

    # calculate the file's total size
    for i in range(number_of_sections):
        pos = first_section + (i * 40)
        size_of_raw_data = data[pe_start + pos:pe_start + pos + 4]
        size_of_raw_data = struct.unpack("<I", size_of_raw_data)[0]
        total_size += size_of_raw_data

    end_list.append(mz_pos + total_size)

# write the potential PE files to new files
# this is the actual carving step
def output_potential_pe_files():
    for i in range(len(start_list)):
        pe_file = data[start_list[i]:end_list[i]]
        pe_filename = "PE-" + str(start_list[i]) + "-" + str(end_list[i])
          
        carve_out = open(pe_output_dir + "/" + pe_filename, "wb")
        carve_out.write(pe_file)
        carve_out.close()

# read in the carved files 64 KB at a time
# then calculate an MD5 hash from the complete file data
def write_hashes():
    hash_list_file = open(hash_output, "w")
    carved_files = os.listdir(pe_output_dir)
    hash_list_file.write("begin")
    
    for filename in carved_files:
        f = open(pe_output_dir + "/" + filename, "rb")
        md5 = hashlib.md5()
        
        while True:
            data = f.read(65536)
            if not data:
                break
            md5.update(data)
            
        f.close()

        hash_list_file.write("\n" + md5.hexdigest())

    hash_list_file.write("\nend")
    hash_list_file.close()

    return len(carved_files)

def run(out_dir, filename):
    # program arguments
    global pe_output_dir
    pe_output_dir = out_dir
    input_file = filename

    forensic_image = open(input_file, "rb")
    global data
    data = forensic_image.read()
    forensic_image.close()

    find_stubs()

    for n in start_list:
        find_size(n)

    try:
        os.mkdir(pe_output_dir)
    except FileExistsError:
        pass
            
    output_potential_pe_files()
    number_of_files = write_hashes()

    # number of files present in the pe_output_dir directory
    return number_of_files
